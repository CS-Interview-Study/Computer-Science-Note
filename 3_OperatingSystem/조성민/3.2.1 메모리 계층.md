# 구성

- 레지스터
    - CPU 안에 있는 작은 메모리
    - 휘발성
    - 가장 빠른 속도
    - 가장 작은 기억 용량
- 캐시
    - L1, L2 캐시를 지칭 (L3도 있음)
    - 휘발성
    - 속도 빠름
    - 작은 기억 용량
- 주기억장치
    - RAM을 지칭
    - 휘발성
    - 속도 보통
    - 보통의 기억 용량
- 보조기억장치
    - HDD, SSD를 지칭
    - 비휘발성
    - 속도 낮음
    - 많은 기억 용량

- RAM
    - 보조기억장치로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요 시마다 CPU에 빠르게 전달한다.

구성이 나뉘어져 있는 이유는 경제성과 캐시 때문이다.

# 캐시

- 데이터를 미리 복사해 놓는 임시 저장소
- 빠른 장치와 느린 장치의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
- 데이터에 접근하는 시간, 같은 계산을 다시 하는 시간을 줄인다.

- 캐시 계층
    - 속도 차이를 해결하기 위해 계층과 계층 사이에 존재하는 계층

## 지역성의 원리

캐시 계층을 두지 않고 직접 캐시를 설정할 때 자주 사용하는 데이터를 기반으로 설정한다.

자주 사용하는 데이터의 근거가 지역성이다.

### 시간 지역성

최근 사용한 데이터에 다시 접근하려는 특성

### 공간 지역성

최근 접근한 데이터를 이루고 있는 공간이나 가까운 공간에 접근하려는 특성

# 캐시히트와 캐시미스

- 캐시히트
    - 캐시에서 원하는 데이터를 찾은 것
    - 제어장치를 거쳐 데이터를 가져온다.
    - 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠르다.
- 캐시미스
    - 캐시에서 원하는 데이터가 없어서 찾지 못하고 주 메모리로 가서 데이터를 찾아오는 것
    - 시스템 버스 기반으로 작동하기 때문에 느리다.

## 캐시매핑

캐시 히트를 위해 매핑하는 방법

- 직접 매핑
    - 캐시가 1~10, 메모리가 1~100이 있다면, 캐시 1에 메모리 1~10, 캐시 2에 메모리 11~20 … 이런 식으로 저장
    - 구현이 간단하다.
    - 처리가 빠르다.
    - 비효율적이다.
    - 수정에 취약하다.
    - 충돌이 잦다.
- 연관 매핑
    - 순서를 일치시키지 않고 관련있는 메모리끼리 캐시에 저장한다.
    - 충돌이 적다.
    - 모든 블록을 탐색해야 해서 느리다.
- 집합 연관 매핑
    - 직접 매핑 + 연관 매핑
    - 순서를 일치시키고 일정 그룹을 두어 저장
    - 캐시가 1~10, 메모리가 1~100이 있다면, 캐시 1~5에 메모리 1~50을 무작위로 저장한다.
    - 연관 매핑보다 탐색이 빠르다.

## 웹 브라우저의 캐시

### 쿠키

- 만료 기한이 있는 키-값 저장소
- same site 옵션을 strict로 설정하지 않았을 경우 다른 도메인에서 요청했을 때 자동 전송된다.
- 4KB까지 데이터를 저장할 수 있다.
- document.cookie로 쿠키를 볼 수 없게 httponly 옵션을 걸어야한다.
- 클라이언트, 서버에서 만료 기한을 정할 수 있다. 보통 서버에서 정한다.

### 로컬 스토리지

- 만료 기한이 없는 키-값 저장소
- 5MB까지 저장할 수 있다.
- 웹 브라우저를 닫아도 유지된다.
- HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없다.
- 클라이언트에서만 수정 가능하다.

### 세션 스토리지

- 만료 기한이 없는 키-값 저장소
- 탭 단위로 생성
- 탭을 닫으면 데이터가 삭제된다.
- 5MB까지 저장할 수 있다.
- HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없다.
- 클라이언트에서만 수정 가능하다.

# 추가 공부 사항

## 메모리 공간 (RAM 내부)

- 코드(Code) 영역: 실행할 프로그램의 코드
- 데이터(Data) 영역: 전역 변수, 정적 변수
- 힙(Heap) 영역: 런타임 시 크기가 결정됨(사용자의 동적 할당)
- 스택(Stack) 영역: 컴파일 타임에 크기가 결정됨

### 코드(Code) 영역

- 작성한 소스코드가 저장되는 영역으로 텍스트 영역이라고도 부른다.
- 기계어 형태(0,1)로 저장한다.
- 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 함수, 제어문, 상수 등이 여기에 지정된다.
- CPU는 코드 영역에 저장된 명령어들을 하나씩 가져가서 실행한다.

### 데이터(Data) 영역

- 전역 변수와 정적 변수(static)가 할당되는 영역이다.
- 메인 함수 전에 선언되어 프로그램의 시작과 동시에 할당되고 프로그램이 종료돼야 메모리가 소멸된다.

### 힙(Heap) 영역

- 이 공간에 메모리 할당하는 것을 동적 할당(Dynamic Memory Allocation) 이라고 부른다.
- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
- 응용 프로그램이 종료될 때까지 메모리가 유지되기 때문에 사용하고 난 후 반드시 매모리 해제를 해줘야 한다.(memory leak 발생), Java에서는 가비지 컬렉터가 자동으로 해제한다
- 영역 중 유일하게 런타임시 크기가 결정
- 참조형(Reference Type) 데이터 타입을 갖는 객체(인스턴스), 배열 등이 저장되는 공간,단 힙 영역에 있는 오브젝트들을 가리키는 레퍼런스 변수는 스택에 적재
- 메모리의 낮은 주소부터 할당되는 선입선출(FIFO) 구조

### 스택(Stack) 영역

- 프로그램이 자동으로 사용하는 임시 메모리 영역
- 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 영역
- 함수 호출이 완료되면 저장된 메모리도 해제된다
- 메모리의 높은 주소부터 할당되는 후입선출(LIFO) 구조

![image](https://github.com/user-attachments/assets/0c85aeee-1ac4-40a2-8d90-99104aa53ebf)

Heap 영역과 Stack 영역은 사실 같은 공간을 공유한다. Heap이 메모리 위쪽 주소부터 할당되면 Stack은 아래쪽부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데, 이를 각각 Heap Overflow, Stack Overflow 라고 칭한다.

따라서 Stack 영역이 클수록 Heap 영역이 작아지고, Heap 영역이 크면 Stack 영역이 작아진다.

### **컴파일 타임**

- 작성한 소스코드가 컴파일(compile)이란 과정을 통해 **기계가 읽을 수 있는 형태로 변환되는 과정**

### **런타임**

- 컴파일 과정을 마친 컴퓨터 프로그램이 실행되고 있는 환경 또는 동작되는 동안의 시간

