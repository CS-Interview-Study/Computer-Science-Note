## 공유 자원 (shared resource)

시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수
이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition)라고 함

## 임계 영역 (critical section)

공유 자원의 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역
즉, 둘 이상의 프로세스가 동시에 접근해서는 안 되는 공유 자원에 접근하는 코드의 일부

### 해결 조건

- **상호 배제** : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
- **한정 대기** : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다. (무한 대기 x)
- **융통성** : 한 프로세스가 다른 프로세스의 일을 방해해서는 안 된다.

## 임계 영역 해결 방법

### 뮤텍스 (Mutex)

공유 자원을 사용하기 전에 설정하고 사용한 후에 해제하는 잠금
잠금이 설정되면 다른 스레드는 잠김 코드 영역에 접근 불가
하나의 상태(잠금 or 잠금 해제)만 가짐

### 세마포어 (Semaphore)

간단한 정수 값과 두 가지 함수 wait(P 함수), signal(V 함수)로 공유 자원에 대한 접근을 처리
프로세스가 공유 자원에 접근 → 세마포어에서 wait() 작업 수행
프로세스가 공유 자원을 해제 → 세마포어에서 signal() 작업 수행
바이너리 세마포어 : 0과 1의 두 가지 값만 가질 수 있는 세마포어
카운팅 세마포어 : 여러 개의 값을 가질 수 있는 세마포어. 여러 자원에 대한 접근을 제어하는 데 사용

### 모니터

둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공
모니터큐를 통해 공유 자원에 대한 작업들을 순차적으로 정리

## 교착 상태

두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

### 교착 상태의 원인

- **상호 배제** : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능
- **점유 대기** : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
- **비선점** : 다른 프로세스의 자원을 강제적으로 가져올 수 없음
- **환형 대기** : 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황

### 교착 상태의 해결 방법

1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계
2. 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 ‘은행원 알고리즘’ 사용
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 제거
4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료

# CPU 스케줄링 알고리즘

운영체제는 CPU 스케줄링을 통해 Ready Queue에 있는 프로세스 중 어떤 프로세스를 CPU에 할당할 것인지 결정함
이때 CPU 스케줄링 알고리즘을 통해 어떤 프로세스를 할당할지 결정
CPU 스케줄러가 스케줄링을 결정하는 상황

1. 실행 상태에서 대기 상태로 전환될 때 (ex. I/O 발생)
2. 실행 상태에서 준비 상태로 전환될 때 (ex. 인터럽트 발생)
3. 대기 상태에서 준비 상태로 전환될 때 (ex. I/O 완료)
4. 종료될 때

- 비선점형 스케줄링: 1번과 4번 상황에서만 스케줄링이 발생하는 것
    - 프로세스가 CPU를 점유하고 있는 경우 강제로 프로세스를 중지하지 않고 프로세스가 스스로 CPU 소유권을 포기하는 방식
    - 필요한 문맥 교환만 일어나기 때문에 오버헤드가 상대적으로 적음
    - 프로세스의 배치에 따라 효율성 차이가 많이 남
- 선점형 스케줄링: 이외의 모든 스케줄링
    - 현대 운영체제가 사용하는 방식으로 사용하는 프로세스를 중단시키고 다른 프로세스에 CPU 소유권을 할당하는 방식
    - CPU 처리 시간이 긴 프로세스의 CPU 독점을 막을 수 있어 효율적인 운영 가능
    - 잦은 문맥 교환으로 오버헤드 발생 가능

### CPU 스케줄링 평가 기준

1. CPU 이용률: 시간당 CPU를 사용한 시간의 비율
2. 처리율: 시간당 처리한 작업의 비율
3. 반환 시간: 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간 (작업이 준비 큐에서 기다린 시간 + CPU에서 실행된 시간 + I/O 작업 시간)
4. 대기 시간: 대기열에 들어와 CPU를 할당받기까지 기다린 시간 (준비 큐에서 기다린 모든 시간의 합)
5. 반응 시간: 대기열에서 처음으로 CPU를 얻을 때까지 걸린 시간 (CPU를 할당받은 최초의 순간까지 기다린 시간 한 번만을 측정)

⇒ CPU 이용률, 처리율 극대화, 반환시간, 대기시간, 반응시간 최소화

## 비선점형 스케줄링

### FCFS(First Come First Served)

- 가장 먼저 요청한 프로세스를 가장 먼저 처리하는 방식
- 작성이 간단하고 이해하기 쉬움
- 평균 대기 시간, 응답 시간이 길어질 수 있음
- 반환 시간 면에서는 좋을 수 있음
- Convoy Effect(길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상) 발생 가능

### SJF(Shortest Job First)

- 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 방식
- 긴 시간을 가진 프로세스가 실행되지 않을 수 있음
- 평균 대기 시간이 가장 짧음
- 실제로 다음 프로세스의 실행 시간을 예측하기 어려움 (과거의 실행 시간을 토대로 추측해서 사용)

### 우선순위

- 각각의 프로세스에 우선 순위 넘버를 부여하여 실행하는 방식
- 낮은 순위의 프로세스가 절대 실행되지 않는 기아 문제 발생 가능
- 오래된 작업일수록 우선 순위를 높이는 방식(aging)으로 기아 문제 해결

## 선점형 스케줄링

### 라운드 로빈

- 현대 컴퓨터가 쓰는 우선순위 스케줄링의 일종
- 각각의 프로세스에 동일한 CPU 할당 시간을 부여해 해당 시간 동안만 CPU를 이용하게 하는 방식
- 할당 시간 내에 처리를 완료하지 못하면 다음 프로세스로 넘어감
- n개의 프로세스가 있을 떄 할당 시간을 q로 설정하면 어떤 프로세스도 (n-1)q 시간 이상을 기다리지 않아도 됨
- 응답 시간을 빠르게 할 수 있음
- 할당 시간이 크면 FCFS처럼 작동
- 할당 시간이 짧으면 컨텍스트 스위칭이 잦아져 오버헤드가 많아짐
    
    process sharing이라고 부르며 n개의 프로세스가 프로세서 속도의 1/n씩으로 작동함을 의미

### SRF**(Shortest Remaining Time First)**

- SJF의 선점형 스케줄링 방식
- 남은 프로세스의 실행 시간보다 실행 시간이 더 짧은 프로세스가 도착하면 CPU를 뺏음
- 프로세스가 새로 들어올 때마다 갱신됨

### **Multilevel Queue**

- 우선순위에 따른 준비 큐가 여러개이며 각 큐마다 각자의 스케줄링 알고리즘이 있는 방식
- 큐 사이에서 프로세스 이동 불가능
- 스케줄링 부담이 적으나 유연성이 떨어짐
- 일반적으로 Foreground 프로세스는 Round Robin 방식을 사용하고 Background 프로세스는 FCFS를 사용
- 영구적으로 하나의 큐에 할당되기 때문에 기아 문제 발생 가능
- 보통 CPU 시간의 80%는 Foreground의 RR, 20%는 Background의 FCFS에 할당

### **Multilevel Feedback Queue(MFQ)**

- Multilevel Queue와 비슷하지만, 각 큐 간에 프로세스들이 이동 가능
- 새로운 프로세스는 첫 번째 큐에 들어가 Round Robin 알고리즘으로 동작
    
    시간 할당량 안에 끝내지 못하면 낮은 우선순위 큐로 넘어감
    
    낮은 우선순위 큐는 FCFS 알고리즘으로 동작
    
    → 너무 오래 대기하는 프로세스는 높은 우선순위 큐로 이동하는 aging을 이용해 기아 상태 예방
