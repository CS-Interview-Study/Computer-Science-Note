### 운영체제(OS, Operating System)

사용자에게 편리한 인터페이스 환경을 제공해주고

컴퓨터 시스템의 자원을 효율적으로 관리하는 소프웨어

# Section 1 | 운영체제와 컴퓨터

## 1.1 ) 운영체제의 역할과 구조

### 운영체제의 역할

1. **CPU 스케줄링과 프로세스 관리**
    
    CPU 소유권을 어떤 프로세스에 할당할지
    
    프로세스의 생성과 삭제
    
    자원 할당 및 반환
    
2. **메모리 관리**
    
    한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지
    
3. **디스크 파일 관리**
    
    디스크 파일을 어떠한 방법으로 보관할지
    
4. **I/O 디바이스 관리**
    
    디바이스들과 컴퓨터간에 데이터를 주고받는 것을 관리
    

### 운영체제의 구조

![Untitled](https://github.com/user-attachments/assets/4d5bc671-43b1-49f3-b1c1-0a40bbcd738b)
**🔷 인터페이스**

▪️**GUI**

사용자가 장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태

단순 명령어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호작용 O

▪️**CUI**

그래픽이 아닌 명령어로 처리하는 인터페이스 

**🔷 커널(Kernel)**

운영체제의 핵심적인 기능을 모아놓은 것(엔진 같은 역할) → OS의 성능 좌우 

1. 프로세스 관리 : 프로세스에 CPU 배분
2. 메모리 관리 : 프로세스에 작업공간 배치 및 실제 메모리보다 큰 가상공간 제공
3. 파일 시스템 관리 : 데이터 저장 및 접근 가능한 인터페이스 제공
4. 입출력 관리 : 필요한 입력과 출력 서비스 제공
5. 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경 지원

**🔷시스템콜**

▪️커널이 자신을 보호하기 위해 만든 인터페이스 

→ 사용자, 응용프로그램으로부터 컴퓨터 자원 보호를 위해 직접 접근 차단 

▪️커널이 제공하는 시스템 관련 서비스를 모아놓은 것

▪️ 함수 형태로 제공됨 

▪️유저 모드에서 파일을 읽지 않고 커널 모드로 들어가 파일을 읽고 다시 유저 모드로 돌아가 그 뒤에 있는 유저 프로그램의 로직 수행

▪️시스템콜은 하나의 추상화 계층

➡️ 낮은 단계의 영역 처리에 대한 부분을 많이 신경 쓰지 않고 프로그램 구현 가능

ex) 유저 프로그램이 I/O 요청으로 트랩 발동 → 올바른I/O 요청인지 확인 → 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행

> **modebit**
> 
> 
> 유저 모드와 커널 모드를 구분하기 위해 사용하는 1 또는 0의 값을 가지는 플래그 변수
> 
> 0 : 커널모드 / 1 : 유저모드
> 
> I/O 디바이스들은 OS 통해서만 작동해야 하기 때문에 이를 관리하기 위한 장치 
> 



## 1.2 ) 컴퓨터의 요소

CPU(중앙처리장치), 메인메모리, 입출력장치, 저장장치

### CPU(Central Processing Unit)

인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼

커널이 프로그램을 메모리에 올려 프로세스로 만들면 → CPU가 이를 처리

**🔷 CPU의 구성 요소들**

**▪️산술논리연산장치(ALU, Arithmetic Logic Unit)**

산술 연산과 AND, OR 같은 논리 연산을 계산하는 디지털 회로

**▪️제어장치(CU, Control Unit)**

프로세스 조작을 지시하는 CPU의 한 부품

입출력장치 간 통신을 제어

명령어들을 읽고 해석

데이터 처리를 위한 순서 결정

**▪️레지스터**

CPU 내부에 있는 매우 빠른 임시기억장치

CPU는 자체적으로 데이터 저장할 방법이 없기 때문에 이를 거쳐 데이터를 전달함

CPU는 필요한 데이터를 메모리에서 가져와 레지스터에 저장하고 산술 논리 연산장치를 이용하여 연산 한 후 그 결과를 다시 레지스터에 저장했다가 메모리로 옮김

**🔷 CPU의 연산처리**

1. 제어장치가 메모리에 계산할 값을 로드 + 레지스터에도 로드
2. 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령
3. 제어장치가 계산된 값을 다시 레지스터에서 메모리로 계산한 값 저장

**🔷 인터럽트**

CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영함으로써 시스템의 효율을 높이는 방법

1. CPU가 입출력 관리자에게 입출력 명령 보냄
2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다 놓거나 메모리에 있는 데이터를 저장 장치로 옮김
3. 데이터 전송이 완료되면 입출력 관리자는 **완료 신호**를 CPU에 보냄(=인터럽트)

어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것

IO 디바이스로 인한/ 0으로 숫자를 나누는 산술 연산/ 프로세스 오류

인터럽트 발생 → **인터럽트 핸들러 함수** 실행(인터럽트 벡터에서)

인터럽트 간에는 우선순위 O

> **인터럽트 핸들러 함수**
인터럽트가 발생했을 때 이를 핸들링하기 위한 함수
커널 내부의 IRQ를 통해 호출되며
request_irq()를 통해 함수 등록 가능

**인터럽트 벡터**
CPU가 입출력 관리자에게 여러 개의 입출력 작업을 동시에 시킬 수 있음
그 때마다 인터럽트 여러 번 → 비효율적
→ 여러 인터럽트를 하나의 배열로 만든 인터럽트 벡터 사용
> 

**▪️하드웨어 인터럽트**

IO 디바이스에서 발생하는 인터럽트

인터럽트 라인이 설계된이후 → 순차적인 인터럽트 실행 중지 → OS에 시스템콜을 요청 → 원하는 디바이스로 향해 디바이스에 있는 작은 로컬 버퍼에 접근하여 일 수행(?)

**▪️소프트웨어 인터럽트(트랩, trap)**

프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동

사용자가 의도치 않게 일으키는 인터럽트(자신의 영역을 벗어나는 주소에 접근, 숫자를 0으로 나누는 것…)

## DMA 컨트롤러

Direct Memory Access = 직접 메모리 접근 

DMA = CPU 도움 없이도 메모리에 접근할 수 있도록 입출력 제어기에 부여된 권한

**☑️ 입출력 필요할 때**

CPU는 입출력 관리자에게 입출력 요청 보냄

CPU가 요청한 데이터를 메모리에 가져다 놓아야 함

메모리는 CPU만 접근 권한을 가진 작업 공간..

입출력 관리자에게는 CPU 허락 없이 메모리에 접근할 수 있는 권한 필요!
<br/> <br/>

메인메모리 = CPU가 작업하는 전용 공간 - DMA와 작업 공간이 겹침

→ 메인메모리의 주소 공간 중 일부를 DMA제어기에 할당하여 방지
<br/> <br/>

IO 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치

CPU의 부하를 막아주는 보조 일꾼 - CPU에만 너무 많은 인터럽트 요청이 들어오기 때문에

하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것을 방지

## 메모리

**RAM(Random Access Memory)** : 무작위로 데이터를 읽어도 저장된 위치와 상관없이 같은 속도로 데이터를 읽을 수 있음

**ROM(Read Only Memory)** : 읽기만 가능함 
<br/> <br/>

데이터, 상태, 명령어 등을 기록하는 장치

보통 RAM(Random Access Memory)를 일컬어 메모리라고도 함

메모리가 클수록 많은 일을 동시에 할 수 있음

## 타이머

특정 프로그램에 시간 제한을 다는 역할

시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재

## 디바이스 컨트롤러

컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU

로컬 버퍼 : 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리
