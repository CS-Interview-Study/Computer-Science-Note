# Section 3 | 프로세스와 스레드

### 프로세스(Process)

컴퓨터에 실행되고 있는 프로그램 = CPU 스케줄링의 대상이 되는 작업

프로그램이 메모리에 올라가 인스턴스화된 것

### 스레드(Tread)

프로세스 내 작업의 흐름

## 3.1 ) 프로세스와 컴파일 과정

![Untitled (2)](https://github.com/user-attachments/assets/02519ce7-b1ef-4cc3-b4ff-d9e01f9d529a)

### 전처리

소스 코드의 주석 제거

헤더 파일 병합하여 매크로를 치환

### 컴파일러

오류 처리, 코드 최적화 작업

어셈블리어로 변환

### 어셈블러

목적 코드(Object code)로 변환

확장자는 운영체제마다 다름

### 링커

프로그램 내의 라이브러리 함수 또는 다른 파일들과

목적 코드 결합 → 실행 파일 생성

이때 확장자 .exe .out

---

### 라이브러리

**🔷 정적 라이브러리**

프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식

➕ 시스템 환경 등 외부 의존도가 낮음

➖ 코드 중복 등 메모리 효율성이 떨어짐

**🔷 동적 라이브러리**

프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하여 라이브러리 사용

➕ 메모리 효율성이 좋음

➖ 외부 의존도가 높아짐

## 3.2 ) 프로세스의 상태

![Untitled (3)](https://github.com/user-attachments/assets/af5f4531-a989-409a-bcf3-9c9d0018d832)
### 생성 상태(Create)

프로세스가 생성된 상태

**fork()** 또는 **exec()** 함수를 통해 생성

이때 **PCB 할당**

**🔷 fork()**

부모 프로세스 주소 공간을 그대로 복사

새로운 자식 프로세스 생성X

주소 공간만 복사, 부모 프로세스의 비동기 작업 등 상속X

**🔷 exec()**

새롭게 프로세스 생성하는 함수

### 대기 상태(ready)

메모리 공간이 충분하면 메모리 할당받고

아니면 대기

→ CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

### 대기 중단 상태(ready suspended)

메모리 부족으로 일시 중단된 상태

### 실행 상태(running)

CPU 소유권과 메모리 할당받고

인스트럭션 수행 중인 상태

= CPU burst가 일어난 상태

### 중단 상태(blocked)

어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태

I/O 디바이스에 의한 인터럽트로 많이 발생

ex) 프린트 인쇄 버튼 눌렀을 때

### 일시 중단 상태(blocked suspended)

대기 중단과 유사

중단된 상태에서 프로세스가 실행되려 했으나 메모리 부족으로 일시 중단된 상태

### 종료 상태(terminated)

메모리와 CPU 소유권을 모두 놓고 가는 것

자연스럽게 종료되는 것도 있지만

**부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료(abort) 경우**도 존재

1. 자식 프로세스에 할당된 자원의 한계치 넘음
2. 부모 프로세스 종료됨
3. 사용자가 process.kill 등 명령어로 프로세스 종료

## 3.3 ) 프로세스의 메모리 구조

![Untitled (4)](https://github.com/user-attachments/assets/058fdc22-e463-4b83-b992-135e0102076f)

### 스택 (Stack)

- 위 주소부터 할당
- 동적 할당
- 지역변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역
- 함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 스택에 계속해서 저장
- 재귀함수 호출 시 새로운 스택 프레임이 매번 사용 → 함수내의 변수 집합이 해당 함수의 다른 인스턴스 변수 방해X

### 힙(Heap)

- 동적 할당 변수 저장
- 동적으로 관리되는 자료구조의 경우 힙 영역 사용(벡터..)
- malloc(), free() 한수를 통해 관리

### 데이터 영역

- 정적 할당
- BSS segment
    
    전역변수, static, const로 선언
    
    0으로 초기화/ 초기화가 어떠한 값으로도 되어 있지 않은 변수들이 여기 할당
    
- Data segment
    
    전역변수, static, const로 선언
    
    0 아닌 값으로 초기화된 변수들이 여기 할당
    
- Code segment
    
    프로그램의 코드가 들어감
    

## 3.4 ) PCB

= Process Control Block = 프로세스 제어 블록

운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터

프로세스가 생성되면 운영체제는 해당 PCB를 생성

프로그램이 실행 - 프로세스 생성 - 메모리 할당 - 프로세스의 메타데이터들이 PCB에 저장되어 관리

프로세스의 중요 정보 포함 → 커널 스택의 가장 앞부분에서 관리

> **🔷 메타데이터?**
> 
> 
> 데이터에 관한 구조화된 데이터
> 
> 데이터를 설명하는 작은 데이터
> 
> 대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾기 위해 일정한 규칙에 따라 콘텐츠에 부여되는 데이터
> 

### PCB의 구조

- **프로세스 스케줄링 상태**
    
    프로세스가 CPU에 대한 소유권을 얻은 이후의 상태(준비, 일시중단 등,,)
    
- **프로세스 ID**
    
    프로세스 ID, 해당 프로세스의 자식 프로세스 ID
    
- **프로세스 권한**
    
    컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
    
- **프로그램 카운터**
    
    프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터
    
- **CPU 레지스터**
    
    프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
    
- **CPU 스케줄링 정보**
    
    CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
    
- **계정 정보**
    
    프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
    
- **I/O 상태 정보**
    
    프로세스에 할당된 I/O 디바이스 목록
    

### 컨텍스트 스위칭(Context Switching)

![Untitled (5)](https://github.com/user-attachments/assets/70833910-5a0a-4e93-81d8-77a7e550a226)
▪️ PCB 기반으로 프로세스의 상태를 저장하고 로드시키는 과정

▪️ 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생

▪️ 많은 프로세스가 동시에 구동 되는 것처럼 보이는 방법

▪️ 현대 컴퓨터는 멀티코어의 CPU를 가짐

**🔷 비용 : 캐시미스**

캐시 클리어 과정 - 컨텍스트스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환 발생하기 때문에 필요

이 때문에 캐시미스 발생

**🔷 스레드에서의 컨텍스트 스위칭**

스레드에서도 컨텍스트 스위칭 O

스레드는 스택 영역을 제외한 모든 메모리 공유 - 비용과 시간이 더 ⬇️

## 3.5 ) 멀티 프로세싱

여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것

하드웨어 관점 : 여러 개의 프로세서로 작업을 처리하는 것

하나 이상의 일을 병렬로 처리 가능

프로세스 일부에 문제가 발생해도 다른 프로세스 이용하여 처리 가능 - 신뢰성

### 웹 브라우저의 멀티 프로세스 구조

![Untitled (6)](https://github.com/user-attachments/assets/158c1f79-b26b-40d0-8964-479588665744)

크롬 브라우저의 프로세스 구조

- **브라우저 프로세스**
    
    주소 표시줄, 북마크 막대, 뒤로 가기 버튼 등을 담당
    
    네트워크 요청, 파일 접근 같은 권한 담당
    
- **렌더러 프로세스**
    
    웹 사이트가 보이는 부분의 모든 것을 제어
    
- **플러그인 프로세스**
    
    웹 사이트에서 사용하는 플러그인을 제어
    
- **GPU 프로세스**
    
    GPU 이용해서 화면을 그리는 부분을 제어
    

### IPC (Inter Process Communication)

= 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘

Ex) 클라이언트는 데이터 요청, 서버는 이 요청에 응답하는 것

▪️ 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메세지 큐

▪️ 메모리가 완전히 공유되는 스레드보다는 속도 ⬇️

**🔷 공유 메모리(Shared Memory)**

▪️여러 프로세스에 동일한 메모리 블록에 대한 접근 권한 부여 → 프로세스 통신

▪️각 프로세스의 메모리는 다른 프로세스가 접근 불가

→ 공유 메모리를 통해 여러 프로세스가 하나의 메모리 공유

▪️어떠한 매개체를 통해 데이터를 주고받는 것이 X, 메모리 자체를 공유

→ 불필요한 데이터 복사의 오버헤드 X → IPC 방법 중 가장 빠름

→ 동기화 필요

▪️ 하드웨어 관점 : CPU가 접근할 수 있는 큰 랜덤 접근 메머리인 RAM을 가리키기도 함

**🔷 파일**

▪️ 디스크에 저장된 데이터, 파일 서버에서 제공한 데이터

▪️ 이를 기반으로 프로세스 간 통신

**🔷 소켓**

▪️동일한 컴퓨터의 다른 프로세스/ 네트워크의 다른 컴퓨터로

네트워크 인터페이스를 통해 전송하는 데이터

▪️TCP, UDP

**🔷 익명 파이프(unnamed pipe)**

▪️프로세스 간에 FIFO 방식으로 읽히는 임시공간인 파이프를 기반으로 데이터를 주고 받음

▪️ 단 방향 방식의 읽기 전용, 쓰기 전용 파이프

▪️부모, 자식 프로세스 간에만 사용 가능

▪️다른 네트워크 상에서는 사용X

**🔷 명명된 파이프(named pipe)**

▪️파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한

▪️명명된 단방향, 양방향 파이프

▪️클라이언트, 서버 통신을 위한 별도의 파이프 제공

▪️여러 파이프 동시 사용 O

▪️ 컴퓨터 프로세스끼리, 다른 네트워크상의 컴퓨터와도 통신 O

▪️보통 서버용 파이프, 클라이언트용 파이프 구분해서 작동

▪️하나의 인스턴스를 열거나 여러 개의 인스턴스를 기반으로 통신

**🔷 메세지 큐**

▪️메시지를 큐 데이터 구조 형태로 관리하는 것

▪️커널에서 전역적으로 관리 - 커널의 전역변수 형태 등..

▪️ 다른 IPC 방식에 비해 사용 방법이 매우 직관적이고 간단

▪️다른 코드 수정 없이 몇줄의 코드를 추가하여 간단하게 메시지 큐에 접근 가능

▪️공유 메모리 방식에서 쓰기 읽기 빈도가 높으면 동기화 때문에 기능 구현 매우 복잡.. → 대안으로 메시지 큐 사용하기도 함

## 3.6 ) 스레드와 멀티스레딩

### 스레드

![Untitled (7)](https://github.com/user-attachments/assets/bccb83f8-971c-46e7-8971-c49ffeabc4b8)
- 프로세스의 실행 가능한 가장 작은 단위
- 코드, 데이터, 힙 스레드끼리 서로 공유
- 그 외의 영역은 각각 생성

### 멀티스레딩

- 프로세스 내 작업을 여러 개의 스레드(멀티스레드) 처리하는 기법
- 스레드 끼리 자원 공유 → 효율성 ⬆️
    
    Ex) 웹요청 처리 - 새 프로세스 생성 대신 스레드 사용 → 훨씬 적은 리소스 소비
    
    웹 브라우저의 렌더러 프로세스 - 메인 스레드, 워커 스레드, 컴포지터 스레드, 레스터 스레드
    

➕한 스레드 중단(blocked)되어도 다른 스레드는 실행(running) → 중단되지 않은 빠른 처리 가능

➕동시성 장점 

➖ 한 스레드 문제 생기면 다른 스레드에도 영향 → 스레드로 이루어진 프로세스에 영향

## 3.7 ) 공유 자원과 임계 영역

### 공유 자원(Shared resource)

- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는
- 모니터, 프린터, 메모리,,, 등의 자원이나 변수
- **경쟁 상태(race condition)** : 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황

### 임계 영역(critical section)

둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 

접근 순서 등의 이유로 결과가 달라지는 코드 영역

**🔷 해결 방법**

잠금(lock) 매커니즘을 사용

**▪️ 뮤텍스(mutex)**

공유 자원을 lock()을 통해 잠금 설정하고, 사용한 후에는 unlock()을 통해 잠금 해제

**▪️세마포어(semaphore)**

일반화된 뮤텍스

간단한 정수 값, 두 가지 함수 **wait(P함수) signal(V함수)**로 공유자원에 대한 접근 처리

공유자원에 접근하면 - wait() 작업 수행

공유자원을 해제하면 - signal() 작업 수행 

조건 변수 X, 세마포어 값 수정할 때 다른 프로세스나 스레드가 동시에 수정 X

상호배제를 명시적으로 구현해야 함 

**➰바이너리 세마포어**

0과 1 두 가지 값만 가질 수 있는 세마포어

뮤텍스 : 잠금 기반으로 상호배제 - 잠금 메커니즘

세마포어 : 신호 기반으로 상호배제 - 신호 메커니즘

**➰카운팅 세마포어**

여러 개의 값을 가질 수 있는 세마포어

여러 자원에 대한 접근 제어 시 사용

**▪️모니터(monitor)**

둘 이상의 스레드, 프로세스가 공유 자원에 안전하게 접근할 수 있도록

공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공

모니터 큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리

세마포어 보다 구현하기 쉽고 상호배제 자동

▶️ 모두 상호 배제, 한정대기, 융통성 조건 만족

## 3.8 ) 교착 상태(deadlock)

두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

### 교착 상태의 원인

- **상호 배제** : 한 프로세스가 자원 독점, 다른 프로세스 접근 불가
- **점유 대기** : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청
- **비선점** : 다른 프로세스의 자원을 강제로 가져올 수 X
- **환형대기** : 서로가 서로의 자원을 요구하는 상황

### 해결 방법

1. 자원 할당할 때 애초에 조건이 성립되지 않도록 설계
2. 교착상태 가능성이 없을 때만 자원 할당, **은행원 알고리즘** 사용
    
    > **🔷 은행원 알고리즘**
    > 
    > 
    > 총 자원의 양과 현재 할당한 자원의 양을 기준으로
    > 
    > 안정, 불안정 상태로 나누고 
    > 
    > 안정 상태로 가도록 자원을 할당하는 알고리즘
    > 
3. 교착 상태 발생하면 사이클이 있는지 찾아보고 - 관련 프로세스 한 개씩 지우기
4. 매우 드물게 발생 + 처리 비용이 커서 → 발생하면 사용자가 **작업을 종료**함
