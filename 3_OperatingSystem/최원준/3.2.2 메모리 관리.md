---
description: 메모리 관리
---

# 3.2.2 Memory Management

## 가상 메모리(Virtual Memory)

가상 메모리(Virtual Memory)는 메모리 관리 기법의 하나로, 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말합니다. 가상 메모리를 통해 프로세스는 물리적 메모리보다 더 많은 메모리를 사용할 수 있게 되며, 이를 통해 시스템 자원을 효율적으로 관리할 수 있습니다.

### **가상 메모리의 동작 원리**

가상 주소와 실제 주소로 구분되는 두 가지 주소 체계를 사용합니다. 가상 주소는 프로그램이 사용하는 주소이며, 실제 주소는 메모리 관리 장치(Memory Management Unit, MMU)에 의해 가상 주소가 변환된 후 하드웨어에 전달되는 주소입니다. 이는 프로세스가 실제 물리적 메모리 크기를 신경 쓰지 않고 메모리를 사용할 수 있게 합니다.

* **가상 주소(Logical Address)**: 프로그램이 참조하는 주소
* **실제 주소(Physical Address)**: 메모리 관리 장치에 의해 변환된 주소

### **TLB(Translation Lookaside Buffer)**

가상 주소를 실제 주소로 변환하는 과정에서 속도를 높이기 위해 TLB를 사용합니다. TLB는 자주 사용하는 페이지 테이블 항목을 캐싱하여, 변환 속도를 높입니다.

## 스와핑(Swapping)

스와핑은 가상 메모리에 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터를 하드 디스크와 같은 보조 기억장치에 저장하고, 필요할 때 다시 메모리로 불러오는 기법입니다. 스와핑은 주로 시스템의 메모리가 부족할 때 발생하며, 이를 통해 시스템은 제한된 메모리 자원을 효율적으로 사용할 수 있습니다.

### 페이지 폴트(Page Fault)

페이지 폴트는 프로세스가 참조한 주소가 실제 메모리에 존재하지 않을 때 발생하는 현상입니다. 페이지 폴트가 발생하면 운영체제는 다음과 같은 과정을 통해 문제를 해결합니다.

1. 운영체제는 해당 주소가 실제 디스크에 있는지 확인합니다.
2. 만약 있다면, 해당 페이지를 메모리에 로드합니다.
3. 페이지 테이블을 갱신합니다.
4. 프로세스를 다시 실행합니다.

### **스레싱(Thrashing)**

스레싱은 시스템의 메모리 관리에서 중요한 개념입니다. 메모리에 너무 많은 프로세스가 동시에 존재하여 페이지 폴트가 자주 발생하고, 그로 인해 시스템 성능이 급격히 저하되는 현상을 의미합니다. 스레싱이 발생하면 CPU는 유휴 상태로 돌아가게 되며, 전체 시스템 성능이 떨어지게 됩니다. 이를 해결하기 위해 운영체제는 다음과 같은 방법을 사용합니다.

* **메모리 할당량 조정**: 현재 실행 중인 프로세스의 메모리 할당량을 조절하여, 페이지 폴트를 줄이는 방법입니다.
* **작업 세트 관리**: 프로세스가 일정 시간 동안 자주 사용하는 페이지의 집합인 작업 세트를 관리하여, 필요한 페이지가 메모리에 상주하도록 합니다.
* **PFF(Page Fault Frequency)**: 페이지 폴트 빈도를 조절하여, 스레싱을 방지합니다.

## 메모리 할당

메모리 할당은 프로그램이 실행될 때 필요한 메모리 공간을 할당하는 과정입니다. 메모리 할당 방식은 다음과 같이 나뉩니다.

### **고정 분할 방식(Fixed Partition Allocation)**

고정 분할 방식은 메모리를 미리 나누어 관리하는 방식으로, 메모리 공간을 미리 고정된 크기로 분할하여 프로그램을 할당합니다. 이는 간단한 구현이 가능하지만, 내부 단편화 문제가 발생할 수 있습니다.

### **가변 분할 방식(Variable Partition Allocation)**

가변 분할 방식은 프로그램의 크기에 맞춰 동적으로 메모리 공간을 할당하는 방식입니다. 이는 메모리 사용의 효율성을 높일 수 있지만, 외부 단편화 문제가 발생할 수 있습니다.

* **최초 적합(First Fit)**: 빈 메모리 공간 중 가장 먼저 맞는 곳에 할당합니다.
* **최적 적합(Best Fit)**: 빈 메모리 공간 중 가장 적합한 곳에 할당합니다.
* **최악 적합(Worst Fit)**: 빈 메모리 공간 중 가장 큰 곳에 할당합니다.

### 단편화(Fragmentation)

메모리 단편화는 메모리를 할당하고 해제하는 과정에서 발생하는 메모리 조각 현상입니다. 단편화는 내부 단편화와 외부 단편화로 나뉩니다.

* **내부 단편화(Internal Fragmentation)**: 할당된 메모리 블록 내에 사용되지 않는 공간이 발생하는 현상입니다.
* **외부 단편화(External Fragmentation)**: 할당되지 않은 메모리 공간이 여러 개의 작은 조각으로 나뉘어 사용되지 못하는 현상입니다.

단편화를 해결하기 위해 메모리를 재배치하는 압축 기법을 사용할 수 있으며, 페이지 단위로 메모리를 관리하는 페이징 기법도 단편화 문제를 해결하는 데 효과적입니다.

#### 메모리 분할 및 페이지 교체 알고리즘

### **메모리 분할**

* **페이징(Paging)**: 메모리를 고정된 크기의 페이지로 나누어 관리하는 방식으로, 외부 단편화 문제를 해결할 수 있습니다. 페이징은 페이지 테이블을 통해 메모리를 관리하며, 페이지 테이블은 각 페이지의 위치를 저장합니다.
* **세그멘테이션(Segmentation)**: 메모리를 의미 단위로 나누어 관리하는 방식으로, 프로그램의 논리적 구조를 반영합니다. 세그멘테이션은 코드, 데이터, 스택 등을 별도로 관리할 수 있습니다.
* **페이징 세그멘테이션(Paged Segmentation)**: 페이징과 세그멘테이션을 결합한 방식으로, 세그먼트를 다시 페이지 단위로 나누어 관리합니다. 이는 세그멘테이션의 장점을 유지하면서도, 페이징의 효율성을 높일 수 있습니다.

### **페이지 교체 알고리즘**

페이지 교체 알고리즘은 메모리에 빈 공간이 없을 때 어떤 페이지를 교체할지 결정하는 방법입니다. 대표적인 페이지 교체 알고리즘으로는 다음과 같은 것들이 있습니다.

* **FIFO(First In First Out)**: 가장 먼저 들어온 페이지를 가장 먼저 교체하는 방식입니다. 단순하지만, 성능이 떨어질 수 있습니다.
* **LRU(Least Recently Used)**: 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식입니다. 시간 지역성을 반영하여 성능이 좋지만, 구현이 복잡할 수 있습니다.
* **LFU(Least Frequently Used)**: 사용 빈도가 가장 낮은 페이지를 교체하는 방식입니다. 단순하지만, 최근 사용 여부를 반영하지 않아 성능이 떨어질 수 있습니다.
* **NUR(Not Used Recently)**: LRU에서 발전된 방식으로, 최근에 사용되지 않은 페이지를 교체하는 방식입니다. 주기적으로 비트를 검사하여 교체할 페이지를 결정합니다.

## 결론

메모리 관리 기법은 컴퓨터 시스템의 성능을 극대화하고, 자원을 효율적으로 사용하는 데 필수적입니다. 가상 메모리, 스와핑, 페이지 폴트, 단편화, 페이지 교체 알고리즘 등 다양한 기법을 통해 메모리를 효과적으로 관리할 수 있습니다. 이러한 기법을 이해하고 활용하면 시스템 성능을 최적화하고, 안정적인 운영을 보장할 수 있습니다.
