# Section 2 | 선형 자료 구조

요소가 일렬로 나열되어 있는 자료구조

## 2.1 ) 연결 리스트

데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료구조

> **삽입 /삭제** : O(1) - 데이터 추가와 삭제를 많이 할 때 사용
> 
> 
> **탐색** : O(n)
> 

### 싱글 연결 리스트

next 포인터만 가짐

### 이중 연결 리스트

next 포인터와 prev 포인터를 가짐

### 원형 이중 연결 리스트

이중 연결 리스트와 같지만

마지막 노드의 next 포인터가 헤드 노드를 가리키는 것

## 2.2 ) 배열

- 같은 타입의 변수들
- 크기가 정해져 있음
- 인접한 메모리 위치에 있는 데이터를 모아 놓은 집합
- 중복 허용
- 순서 O

> **접근**: O(1) - 랜덤 접근 가능, 접근을 많이 할 때 사용
> 
> 
> **삽입/삭제**: O(n)
> 

### 랜덤 접근과 순차적 접근

**랜덤 접근** : 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능

↔ **순차적 접근** : 데이터를 저장된 순서대로 검색해야 함

### 배열과 연결 리스트 비교

배열 : 몇 번째 상자인지만 알면 해당 상자의 요소를 끄집어낼 수 있음 - 랜덤 접근 가능

연결 리스트 : 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 함 - 랜덤 접근 불가능

데이터 추가, 삭제는 연결리스트가 더 빠름

## 2.3 ) 벡터

동적으로 요소를 할당 할 수 있는 동적 배열

- 컴파일 시점에 개수를 모를 때 사용
- 중복 허용
- 순서 O
- 랜덤 접근 가능

> **탐색, 맨 뒤 요소 삭제 삽입** : O(1)
> 
> 
> **맨 뒤가 아닌 요소 삭제 삽입** : O(n)
> 

### push_back()은 O(1)의 시간이 걸리는 이유

벡터의 크기가 증가되는 시간 복잡도가 amortized 복잡도(상수시간 복잡도 O(1) )과 유사한 시간 복잡도를 가지기 때문 

- **+) amortized analysis(분활 상환 분석)**
    
    주어진 알고리즘의 시간 복잡도나 프로그램을 수행하는 데에 소요되는 시간, 메모리 같은 자원 사용량을 분석하기 위해 사용하는 기법
    
    전반적인 연산 집합에 대해 비용이 높은 연산, 덜한 연산 모두 함께 고려하는 기법
    

push_back()을 할 때마다 매번 크기가 증가하는 것이 X

2의 제곱승 + 1 마다 크기를 2배로 늘림 

➡️ 평균적으로 드는 비용을 계산해보면 상수 시간에 가까운 amortized 복잡도를 가짐

## 2.4 ) 스택

LIFO 성질을 가진 자료구조

재귀적인 알고리즘, 웹브라우저 방문 기록 등에 사용

> **삽입 /삭제** : O(1)
> 
> 
> **탐색:** O(n)
> 

## 2.5 ) 큐

FIFO 성질을 가진 자료구조

CPU 작업 기다리는 프로세스, 스레드 행렬, 네트워크 접속 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용

> **삽입 /삭제** : O(1)
> 
> 
> **탐색:** O(n)
>
