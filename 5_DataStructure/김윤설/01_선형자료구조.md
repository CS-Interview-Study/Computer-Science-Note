## 배열 (Array)

### **정의**

입력된 데이터들이 메모리 공간에서 연속적으로 저장되어 있는 자료구조

메모리 상에서 연속적으로 저장되어 있는 특징을 갖기 때문에, index를 통한 접근이 용이

배열의 크기는 처음 생성할 때 정하며 이후에는 변경 불가

### 시간 복잡도

- 탐색
    - O(1). 단, 접근하고자 하는 인덱스를 알고 있어야 함
    - 순차적 탐색 시에는 O(n)
- 삽입/삭제
    - 배열의 처음 또는 중간에 삽입 및 삭제 : O(n)
    - 배열의 끝에 삽입 및 삭제 : O(1)

## 연결 리스트 (Linked List)

### 정의

여러 개의 노드들이 순차적으로 연결된 형태를 갖는 자료구조

첫 번째 노드를 head,  마지막 노드를 tail이라고 함

각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어져 있음

노드가 연결된 구조이기 때문에 삽입, 삭제에 용이

Tree 구조의 근간이 되는 자료구조

### 시간 복잡도

- 탐색
    - O(n)
- 삽입/삭제
    - 삽입과 삭제 자체는 O(1)
    - 연결 리스트의 처음에 삽입/삭제 : O(1)
    - 연결 리스트의 중간에 삽입/삭제 : O(n) (탐색시간 소요)
    - 연결 리스트의 끝에 삽입/삭제
        - 끝을 가리키는 별도의 포인터를 갖는 경우 : O(1)
        - 끝을 가리키는 별도의 포인터를 갖지 않는 경우 : O(N) (탐색시간 소요)

## 배열과 연결 리스트 비교

|  | 배열 (Array) | 연결 리스트 (Linked List) |
| --- | --- | --- |
| 장점 | 인덱스를 통한 빠른 접근 가능 | 삽입/삭제 용이 |
| 단점 | 삽입/삭제가 오래 걸림 <br/> 배열 중간의 데이터가 삭제되면 공간 낭비 발생 | 임의 접근 불가능 → 처음부터 탐색 진행 必 |
| 용도 | 빠른 접근이 요구되고, 데이터 삽입/삭제 적을 때 <br/> 순차적인 데이터 추가/삭제 시 | 삽입/삭제 연산 多, 검색 빈도 적을 때 |

## Linked List vs Array List

|  | Linked List | Array List |
| --- | --- | --- |
| 형태 | 자료의 주소 값으로 서로 연결된 형태 | 데이터들이 순서대로 늘어선 배열 형태 |
| 장점 | 데이터 추가/삭제 용이 | 임의의 데이터에 접근이 쉬움 |
| 단점 | 임의의 데이터 접근 시 시간 소요 多 | 데이터 추가/삭제 시 시간 소요 多 |

## 연결 리스트의 종류

### 싱글(단순) 연결 리스트

노드의 데이터 필드에 데이터 값이 저장되고, 링크 필드에 다음 노드의 참조 값을 저장하는 구조

next 포인터만 가짐

head는 가장 앞 노드를 가리키고, 링크 필드가 null인 노드가 마지막 노드

### 이중 연결 리스트

양방향 순회가 가능하도록 두 개의 링크 필드와 한 개의 데이터 필드로 구성된 자료 구조

next 포인터와 prev 포인터를 가짐

head는 가장 앞 노드를 가리키고, tail은 가장 끝 노드를 가리킴

### 원형 연결 리스트

가장 끝 노드의 next 포인터가 head 노드를 가리키는 자료구조

단일 방향 노드, 양방향 노드 모두로 구현 가능

## 벡터 (Vector)

ArrayList와 동일한 구조를 가지며 배열의 크기 변경 시 자동으로 크기가 조절이 되는 자료구조

동기화된 메소드로 구성 → 멀티 스레드가 동시에 이 메소드들을 실행 불가, 하나의 스레드가 실행을 완료해야만 다른 스레드들이 실행 가능 → 멀티 스레드 환경에서 안전하게 객체 추가/삭제 가능

### 특징

```
Vector는 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고,
  하나의 스레드가 실행을 완료해야만 다른 스레드들이 실행할 수 있다.
  그래서 멀티 스레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있다.
```

동적으로 요소를 할당할 수 있는 동적 배열

컴파일 시점에 개수를 모를 때 사용

중복 허용, 순서 有, 랜덤 접근 가능

탐색 및 맨 뒤의 요소 삭제/삽입 시 : O(1)

맨 뒤나 맨 앞이 아니 요소 삭제/삽입 시 : O(n)

## 스택 (Stack)

데이터를 일시적으로 저장하기 위한 자료구조

가장 나중에 넣은 데이터를 가장 먼저 꺼냄 (LIFO, 후입선출)

삽입/삭제에 O(1), 탐색에 O(n) 소요

### 활용 사례

- 재귀 알고리즘
    - 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어준다.
    - 재귀함수를 빠져나와 퇴각 검색(backtrack)을 할 때 스택에 넣어두었던 임시데이터를 꺼낸다.
- 메소드 호출 스택
- 웹 브라우저 방문 기록 (뒤로가기)
- 실행 취소 (undo)
- 역순 문자열 만들기
- 후위 표기법 계산
- 수식의 괄호 검사

## 큐 (Queue)
가장 먼저 넣은 데이터를 가장 먼저 꺼낸다 (FIFO, 선입선출)
삽입/삭제에 O(1), 탐색에 O(n) 소요

### 활용 사례
- 너비 우선 탐색(BFS) 구현
    - 처리해야 할 노드의 리스트를 저장하는 용도로 큐 사용
- 캐시 구현
- 우선순위가 같은 작업 예약 (인쇄 대기열)
- 선입선출이 필요한 대기열 (티켓 카운터)
- 콜센터 고객 대기시간
- 프린터 출력 처리
- 은행 업무
- 프로세스 스케쥴링
- 네트워크 패킷 처리
