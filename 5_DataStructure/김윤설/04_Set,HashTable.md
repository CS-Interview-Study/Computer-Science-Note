# 셋(set)

순서가 없고 중복을 허용하지 않는 자료구조

## set의 특징

- 데이터를 비순차적으로 저장 (삽입 순서대로 저장되지 않음)
- 수정 가능
- 동일한 값을 여러 번 저장하는 경우 나중에 저장한 값으로 수정됨 (동일한 값 여러 개 저장 불가능)
- 중복 처리를 고려해야 하거나 빠르게 탐색해야 하는 경우 사용

## Java에서 set의 종류

- HashSet: 가장 일반적인 set과 Hash 알고리즘을 적용한 자료구조로 가장 빠름
- TreeSet: 저장된 데이터의 값에 따라 오름차순으로 정렬됨
- LinkedHashSet: 값의 중복은 허용되지 않으나 Linked의 개념을 이용하여 입력 순서대로 데이터가 정렬됨

### HashSet

저장하고자 하는 값을 해시 코드로 변환하고, 해당 해시 코드의 주소에 값을 저장하는 set
값 자체가 메모리 주소가 되기 때문에 같은 위치에 여러 개의 값을 저장할 수 없음

HashSet의 시간 복잡도
- 저장: O(1)
- 탐색: O(1)

### TreeSet
이진 트리 기반의 레드-블랙 트리를 사용한 set

<aside>
💡 레드-블랙 트리: 자식 노드가 최대 2개가 될 수 있는 이진 트리 개념에 더해 한 노드를 기준으로 작은 값을 왼쪽, 큰 값을 오른쪽에 저장하는 개념을 추가한 트리
</aside>

탐색 순서
1. 데이터가 들어오면 루트부터 비교
2. 비교의 결과에 따라 우측으로 갈지 좌측으로 갈지 결정
3. 비교할 수 없을 때까지 반복

TreeSet의 시간 복잡도
- 저장: O(log n)
- 탐색: O(log n)

# 해시 테이블

Key, Value로 데이터를 저장하는 자료 구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조
내부적으로 buckets이라는 배열에 데이터를 저장하고 각 key 값에 해시 함수를 적용해 생성한 배열의 index를 활용하여 값을 저장하거나 검색함

**해시 테이블 데이터 저장 방법**
(Key, Value)가 ("John Smith", "521-1234")인 데이터를 크기가 16인 해시 테이블에 저장하는 경우

1. index = hash_function("John Smith") % 16 연산을 통해 index 값을 계산
2. array[index] = "521-1234" 로 전화번호를 저장

## 해시 함수

해시 함수에서는 고유한 인덱스 값을 설정하는 것이 중요함
해시 테이블에 사용되는 대표적인 함수

- Division Method: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산 (테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용하는 것이 효과가 좋음
- Digit Folding: 각 key의 문자열을 아스키 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용
- Multiplication Method: 숫자로 된 key 값 K와 0과 1 사이의 실수인 A, 보통 2의 제곱수인 m을 사용해 다음과 같은 계산을 통해 해시값 생성
    
    `h(k) = (kAmod1) x m`
    
- Univeral Hashing: 다수의 해시 함수를 만들어 집합에 넣어두고 무작위로 해시 함수를 선택해 해시값 생성

## 해시 값 충돌 해결 방법

해시 함수를 돌려 나온 값이 동일해 중복된 인덱스가 생기는 경우 해결 방법)

### 분리 연결법(Separate Chaining)

- 동일한 버킷의 데이터에 추가 메모리를 사용하여 다음 데이터의 주소를 저장 (동일한 버킷으로 접근하는 데이터를 연결하여 관리)
- Java8의 해시 테이블의 경우 Self-Balancing Binary Search Tree 자료 구조를 사용해 Chaining 방식 구현
- 장점
    - 해시 테이블을 확장하지 않아도 됨
    - 간단하게 구현 가능
    - 손쉽게 삭제 가능
- 단점
    - 데이터의 수가 많아지면 동일한 버킷에 chaining되는 데이터가 많아져 캐시의 효율성 감소
    
### 개방 주소법(Open Addressing)

- 추가적인 메모리를 사용하지 않고 비어 있는 해시 테이블을 사용하는 방법으로 다음 비어 있는 주소에 데이터를 저장함
- Open Addressing 구현 방법
    - Linear Probing: 현재의 버킷 인덱스로부터 고정폭만큼 이동하여 차례대로 검색해 비어 있는 버킷에 데이터 저장
        바로 인접한 인덱스에 데이터를 삽입하기 때문에 데이터가 밀집되는 클러스터링 문제가 발생하고 이로 인해 탐색과 삭제가 느려질 수 있음
        
    - Quadratic Porbing: 해시의 저장 순서 폭을 제곱으로 저장하는 방식으로 처음 충돌이 발생한 경우 1만큼 이동하고 이후 충돌이 발생하면 2^2, 3^2 칸씩 점진적으로 증가하여 이동
        초기 해시값이 같을 경우 클러스터링 문제 발생 가능

    - Double Hashing Probing: 클러스터링 문제를 해결하기 위해 고안된 방법으로 두 개의 해시 함수를 사용 (다른 방법보다 많은 연산 필요)
        첫 번째 해시 함수: 해시 값을 찾기 위해 사용
        두 번째 해시 함수: 충돌 발생 시 탐사폭 계산을 위해 사용
        
- Open Addressing에서 데이터 삭제 시 삭제된 공간은 Dummy Space로 활용되기 때문에 Hash Table을 재정리 해주는 작업 필요

## HashMap vs HashTable

Java에서 HashMap과 HashTable의 차이는 동기화 지원 여부에 있음

- HashMap: 병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황
- HashTable: 병렬 처리를 하면서 자원의 동기화를 고려해야 하는 상황
