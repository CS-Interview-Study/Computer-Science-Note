# Section 5 | HTTP

애플리케이션 계층 - 웹서비스 통신에 사용

## 5.1 ) HTTP/1.0

한 연결당 하나의 요청 처리 → RTT 증가

서버로 부터 파일을 가져올 때마다 TCP의 3-웨이 핸드셰이크를 계속해서 열어야 하기 때문에 **RTT가 증가하는 단점**이 있음

서버에 부담 ↑, 사용자 응답시간 ↑

> **RTT?**
> 
> 
> 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간
> 
> 패킷 왕복 시간
> 

### RTT 증가 해결 방법

- **이미지 스플리팅**
    
    많은 이미지를 다운 받으면 과부하 → 많은 이미지가 합쳐 있는 하나의 이미지를 다운받고 이를 기반으로 background-image의 position을 이용하여 이미지를 표기하는 방법
    
- **코드 압축**
    
    코드를 압축해서 개행문자, 빈칸을 없애서 코드의 용량을 줄이는 방법
    
- **이미지 Base64 인코딩**
    
    이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법
    
    서버와의 연결을 열고 이미지에 대해 HTTP요청을 할 필요가 없다는 장점
    
    다만 크기가 더 커지는 단점이 있음 
    
    > **인코딩?**
    > 
    > 
    > 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해 다른 형태나 형식으로 변환하는 처리 방식
    > 

<aside>
💙 요청을 보낼 때마다 연결을 맺는 방법입니다. 따라서 패킷 왕복시간인 RTT가 증가한다는 단점이 있습니다. 이를 해결하기 위해 코드 압축, 이미지 스플리팅 방법을 사용합니다.

</aside>

## 5.2 ) HTTP/1.1

➕ 매번 TCP 연결을 하는 것이 아니라

한 번 TCP 초기화 → **keep-alive**라는 옵션으로 여러 개의 파일을 송수신할 수 있게 바뀜

➕ 1.0 에도 있었지만 표준화가 되어 있지 않았고 1.1부터 표준화 되어 기본 옵션으로 설정

➖ 문서 안에 포함된 다수의 리소스(이미지, 동영상 등)를 처리하려면 요청할 리소스 개수에 비례하여 대기 시간이 길어지는 단점

➖ 헤더에는 쿠키 등 많은 메타 데이터가 들어 있고 압축이 되지 않아 무거움

### HOL Blocking(Head Of Line Blocking)

네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상

<aside>
💙 Keep alive라는 옵션으로 매번 연결을 하지 않고 연결 재사용이 가능한 버전입니다. 다만 앞선 요청의 처리가 늦어지면 그 다음 요청의 응답들도 늦어지는 HOL Blocking 문제가 발생합니다.

</aside>

## 5.3 ) HTTP/2

SPDY 프로토콜에서 파생된 HTTP/1.X 보다 

지연시간을 줄이고 응답시간을 더빠르게 할 수 있으며 

멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜

HTTPS 위에서 동작

### 멀티플렉싱

- HTTP/1.X 의 HOL Blocking 문제 해결 방법
- 여러 개의 스트림을 사용하여 송수신하는 방법

![Untitled (13)](https://github.com/user-attachments/assets/194f78e1-d722-4042-986a-82e608e1ff53)

애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어

병렬적인 스트림을 통해 데이터를 서로 송수신한 이후 다시 조립

➕ 단일 연결을 사용하여 병렬로 여러 요청과 응답 가능

➕ 특정 스트림의 패킷이 손실 → 해당 스트림에만 영향, 나머지 스트림은 멀쩡하게 동작 O

> **스트림?**
> 
> 
> 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
> 

### 헤더 압축

- HTTP/1.X 의 큰 헤더 문제 해결 방법
- 허프만 코딩 압축 알고리즘을 사용하여 해결
- HPACK 압축 형식을 가짐

> **허프만 코딩**
> 
> 
> 문자열을 문자 단위로 쪼개 빈도수를 세어
> 
> 빈도가 높은 정보 - 적은 비트 수 
> 
> 빈도가 낮은 정보 - 많은 비트수 
> 
> 로 표현하여 전체 데이터 표현에 필요한 비트양을 줄이는 원리
> 

### 서버 푸시

- HTTP/1.X 의 클라이언트가 서버에 요청해야 파일 다운 가능한 문제 해결 방법
- 클라이언트 요청 없이 서버가 바로 리소스 푸시 가능

<aside>
💙 HTTP란 애플리케이션 계층에서 웹서비스 통신에 사용되는 프로토콜입니다. HTTP/2 는 HTTP/1 버전의 HOL Blocking문제를 해결하는 멀티플렉싱 방법을 지원합니다. 이는 프레임 단위로 나눠서 전송을 관리하는 방법입니다. 이를 통해 단일 연결로 다수의 요청과 응답이 가능합니다. 또한 HTTP/1 에서의 크기가 큰 헤더 문제를 해결하기 위해 헤더 압축을 사용합니다. 이 때 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 가집니다. 그리고 클라이언트 요청 없이 필요한 리소스를 서버가 알아서 찾아주는 서버푸시를 사용합니다.

</aside>

## 5.4 ) HTTPS

애플리케이션 계층과 전송 계층사이에 **신뢰 계층인 SSL/TLS 계층**을 넣은 신뢰할 수 있는 HTTP 요청

이를 통해 **통신을 암호화** 함

### SSL/TLS

- SSL(Secure Socket Layer) → TLS(Transport Layer Security Protocol)로 버전이 올라가며 TLS로 명칭이 변경되었으나 합쳐서 많이 부름
- **전송 계층**에서 **보안을 제공하는 프로토콜**
    
    → 클라이언트와 서버가 통신할 때 이를 통해 제3자가 메시지를 도청하거나 변조하지 못하게 함
    
- **보안 세션**을 기반으로 데이터를 암호화

### **보안세션**

보안이 시작되고 끝나는 동안 유지되는 세션

만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용

SSL/TLS는 **핸드 셰이크**를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 공유

> **세션**
> 
> 
> 운영체제가 어떤 사용자로부터 자신의 자산 이용을 허락하는 일정 기간
> 

클라이언트에서 **사이퍼 슈트**를 서버에 전달하면

서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인

제공할 수 있다면 서버에서 클라이언트로 인증서를 보내는 **인증 메커니즘**이 시작

이후 해싱 알고리즘 등으로 **암호화된 데이터의 송수신**이 시작

- **사이퍼 슈트(Cypher Suites)**
    
    프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약
    
- **인증 메커니즘**
    
    CA에서 발급한 인증서를 기반으로 안전한 연결을 시작하는 데 있어 필요한 공개키를 클라이언트에 제공하고
    
    사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장
    
- **암호화 알고리즘**
    
    대수곡선 기반의 **ECDHE** 또는 모듈식 기반의 **DHE**를 사용
    
    둘 다 디피-헬만 방식을 근간으로 제작
    
    > 디피-헬만 키 교환 암호화 알고리즘
    > 
- **해싱 알고리즘**
    
    데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘 
    
    > **SHA-256 알고리즘**
    해시 함수 결괏값이 256비트인 알고리즘
    > 
    
    > **해시** : 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값
    > 
    > 
    > **해싱** : 임의의 데이터를 해시로 바꿔주는 일
    > 
    > **해시 함수** : 임의의 데이터를 입력 받아 일정한 길이의 데이터로 바꿔주는 함수
    > 
    

### HTTPS 구축 방법

1. 직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스를 구축
2. 서버 앞단의 HTTPS 제공하는 로드밸런서를 두기
3. 서버 앞단에 HTTPS를 제공하는 CDN을 두기

<aside>
💙 HTTPS는 애플리케이션 계층과 전송 계층 사이에 보안을 담당하는 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청을 말합니다.
SSL/TLS 계층은 전송계층에서 보안을 제공하는 프로토콜로 보안세션을 기반으로 데이터를 암호화합니다.

</aside>

## 5.5 ) HTTP/3

- WWW에서 정보를 교환하는 데에 사용되는 HTTP의 3번째 버전
- **QUIC**라는 계층 위에서 돌아감
- TCP가 아닌 **UDP기반**으로 돌아감
    
    → 통신을 시작할 때 3웨이 핸드셰이크 과정 X
    
    → 첫 연결 설정에 1-RTT만 소요(클라이언트가 서버에 어떤 신호를 한 번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신 시작 가능)
    
    → 초기 연결 설정 시 지연 시간 감소
    
- 멀티플렉싱 O
- 순방향 오류 수정 메커니즘 적용
    
    → 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식
    
    → 열악한 네트워크 환경에서도 낮은 패킷 손실률
