## 옵저버 패턴

주체가 객체 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

**일대다의 종속성**을 정의 

주로 **이벤트 기반 시스템**에 사용

> ✔️ **C++에서의 상속, Interface**
> 
> - **상속**
>     
>     자식 클래스가 부모 클래스의 속성과 메서드를 물려받는 것
>     
>     코드의 재사용성, 클래스의 확장 용이, 유지보수 향상
>     
> - **Interface?**
>     
>     **자바** - 다중 상속이 불가하기 때문에 인터페이스를 사용
>     
>     **C++** - 다중 상속이 자유롭고 인터페이스라는 키워드 X/ 추상 클래스를 순수 가상함수만으로 선언하여  Interface처럼 사용 
>     
<br/>

### 유니티에서의 옵저버 패턴(이벤트 시스템)

여러 메소드를 동시에 실행해야 하는 상황은 서로 매우 의존적인 상황이 됨

  *Ex) 좀비 사망 → 애니메이션, UI변경, 플레이어 점수 변경 등..* 

옵저버 객체들은 Subject 객체를 구독, Subject 객체는 옵저버 객체들의 이벤트에게 신호를 주는 역할

- 장점
    
    Subject의 상태를 주기적으로 조회 안 해도 됨
    
    클래스간의 디커플링을 가능하게 함
    
    Subject 코드 변경 없이 새 옵저버 클래스 도입 가능 → 개방 폐쇄 원칙 O
    
- 단점
    
    옵저버 알림 순서 제어 불가
    
    다수의 옵저버 객체 등록후 해지하지 않으면 메모리 누수 발생


---
  🥐 옵저버패턴은 주체가 객체의 상태변화를 관찰하다가, 변화가 발생하면 옵저버 목록에 있는 옵저버들에게 알림을 주는 디자인패턴입니다. 이는 일대다의 관계를 정의하고, 주로 이벤트 시스템에서 활용됩니다. 유니티에서도 이벤트 시스템을 설계할 때 사용되는 방법입니다.
(게임을 설계하다보면, 좀비가 죽었을 때 ui변경, 애니메이션 실행 등 동시에 여러 함수를 실행해야 할 경우가 많습니다. 이런 상황은 서로 매우 의존적인 상황이 되기 때문에 옵저버 패턴을 활용해주는 것이 좋습니다. )
이 패턴을 사용하게 되면, 객체의 상태를 주기적으로 확인해주지 않아도 되고, 클래스간의 디커플링을 가능하게 해줍니다. 그리고 객체 코드의 수정없이, 옵저버 클래스를 추가할 수 있다는 장점이 있습니다.
단점은, 옵저버 알림 순서를 제어할 수 없고, 옵저버 객체 등록후 해제하지 않으면 메모리의 누수가 발생할 수 있습니다.
  
