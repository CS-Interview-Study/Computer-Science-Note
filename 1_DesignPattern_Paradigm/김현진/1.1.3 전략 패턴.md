## 전략 패턴

객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고, 전략이라고 부르는 **캡슐화한 알고리즘**을 Context 안에서 바꿔주며 상호 교체가 가능하게 만드는 패턴

바뀌는 부분을 캡슐화하여 추상클래스로 만들고, 상속(Inheritance)보다는 **구성(composition)**을 활용하며, 구체적인 동작은 자식 클래스에서 구현해주는 것

- **장점**
    
    클라이언트는 알고리즘에 의존하지 않고 인터페이스에 의존할 수 있음
    
    알고리즘을 캡슐화하기 때문에 
    
    → 런타임에 알고리즘 교체 가능
    
    → 클라이언트와 독립적으로 알고리즘을 변경 가능
    
    → 재사용성이 좋음 
    
- **단점**
    
    런타임에 알고리즘을 교체하는 경우 오버헤드 발생 가능
    

**+) Context ?**

상황, 맥락, 문맥

개발자가 어떠한 작업을 완료하는 데에 필요한 모든 관련 정보

```csharp
interface Weapon {
    void offensive();
}

class Sword implements Weapon {
    @Override
    public void offensive() {
        System.out.println("칼을 휘두르다");
    }
}

class Shield implements Weapon {
    @Override
    public void offensive() {
        System.out.println("방패로 밀친다");
    }
}

class CrossBow implements Weapon {
    @Override
    public void offensive() {
        System.out.println("석궁을 발사하다");
    }
}
출처: https://inpa.tistory.com/entry/GOF-💠-전략Strategy-패턴-제대로-배워보자#전략_패턴을_적용한_코드_✔️ [Inpa Dev 👨‍💻:티스토리]
```
