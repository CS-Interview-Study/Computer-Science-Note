# Section 5 | 인덱스

## 5.1 ) 인덱스의 필요성

테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있음

인덱스는 보통 B-트리라는 자료구조로 이루어져 있음

## 5.2 ) B-트리

- 루트 노드, 리프 노드, 브랜치 노드로 나뉜다

### 인덱스가 효율적인 이유와 대수확장성

**🔷 인덱스가 효율적인 이유** 

효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와

트리 깊이의 대수확장성 때문

**🔷 대수확장성**

트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것

기본적으로 인덱스가 한 깊이씩 증가 - 최대 인덱스 항목의 수는 4배씩 증가

## 5.3 ) 인덱스 만드는 방법

데이터베이스마다 다름

### MySQL

**🔷 클러스터형 인덱스**

= 테이블당 하나 설정 가능

1. primary key 옵션으로 기본키 만들기
2. 기본키 만들지 않고 unique not null 옵션 붙이기

하나의 인덱스만 생성할 경우 성능 더 좋은 방법

**🔷 세컨더리 인덱스**

보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스

create index,, 명령어를 기반으로 만들기

### MongoDB

도큐먼트를 만들면 자동으로 ObjectID 생성 - 해당 키가 기본키로 설정

세컨더리키도 부가적으로 설정하여 기본키와 같이 쓰는 복합 인덱스 설정 가능

## 5.4 ) 인덱스 최적화 기법

### 1️⃣ 인덱스는 비용이다

인덱스 리스트, 컬렉션 순으로 탐색 - 2번 탐색하도록 강요 - 관련 읽기 비용

컬렉션 수정 시 인덱스도 수정되어야 함 - B-트리 높이 조절 비용, 데이터 효율적으로 조회할 수 있도록 분산 시키는 비용도 들게 됨

➡️ 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것이 좋은 게 아님

컬렉션에서 가져와야 하는 양이 많을 수록 인덱스 사용 비효율적

### 2️⃣ 항상 테스팅하라

서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에

**서비스 특징**에 따라 최적화 기법이 다르다

explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 함

### 3️⃣ 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

복합 인덱스를 생성할 때는 순서가 있고,

생성 순서에 따라 인덱스 성능이 달라짐

1. 어떠한 값과 같음을 비교하는 쿼리가 있다면 제일 먼저 인덱스로 설정
2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정
3. 다중 값을 출력해야 하는 필드라면 나중에 인덱스를 설정
4. 카디널리티 : 유니크한 값의 정도/ 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 함
