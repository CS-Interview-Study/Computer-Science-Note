# Section 1 | 데이터베이스의 기본

### 데이터베이스

일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음

### DBMS(DataBase Management System)

데이터베이스를 제어, 관리하는 통합 시스템(sw)

- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 수행
- 실시간 접근과 동시 공유 가능
- 데이터베이스 위에 DBMS, 그 위에 응용프로그램이 있는 구조로 데이터를 주고받음

## 1.1 ) 엔터티(Entity)

= 사람, 장소, 물건 등 여러 개의 속성을 지닌 명사

서비스의 요구 사항에 맞춰 속성이 정해짐

### 약한 엔터티와 강한 엔터티

A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면

**A :** 약한 엔터티 **B :** 강한 엔터티

## 1.2 ) 릴레이션(Relation)

정보를 구분하여 저장하는 기본 단위

엔터티에 관한 데이터를 릴레이션 하나에 담아서 관리

행과 열로 구성된 테이블

> **관계형 데이터베이스**에서는 **테이블**
> 
> 
> **NoSQL 데이터베이스**에서는 **컬렉션**
> 

### 테이블과 컬렉션

**🔷 관계형 데이터베이스**

▪️MySQL

▪️테이블

▪️레코드 - 테이블 - 데이터베이스 구조

**🔷 NoSQL 데이터베이스**

▪️MongoDB

▪️컬렉션

▪️도큐먼트 - 컬렉션 - 데이터베이스 구조

### ➕

릴레이션은 스키마와 인스턴스로 이루어짐

**스키마** : 테이블의 첫 행인 헤더, 속석, 자료타입 등

**인스턴스** : 정의된 스키마에 따라 테이블에 실제로 저장되는 데이터 집합

**투플(tuple)** : 릴레이션에서 한 행 (이는 서로 중복되면 X)

**카디날리티** : 투플의 수

<img width="583" alt="image" src="https://github.com/user-attachments/assets/1048da25-ab75-4d59-8126-efd76809ecac">


## 1.3 ) 속성(Attribute) - 열(column)

릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

Ex) ‘차’ 라는 엔터티의 속성 : 차 넘버, 바퀴 수, 차 색깔, 차종 등

## 1.4) 도메인(Domain)

릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

Ex) ‘성별’이라는 속성의 도메인 : {남, 여} 라는 집합

## 1.5) 필드와 레코드

![image (1)](https://github.com/user-attachments/assets/b9f894e0-62d8-486f-a07e-9ee1f6e5b933)

### 필드타입

Ex) 이름 : 문자열, 전화번호 : 숫자,,,

이러한 타입은 DBMS마다 다름(MySQL 기준으로 설명)

**🔷 숫자 타입**

▪️TINYINT, SMALLINT, MEDIYMINT, INT, BIGINT…

**🔷 날짜 타입**

▪️**DATE**

날짜 O, 시간 X

**▪️DATETIME**

날짜 O, 시간 O

**▪️TIMESTAMP**

날짜 O, 시간 O

**🔷 문자 타입**

▪️CHAR

고정 길이 문자열

CHAR(100) → 10글자를 저장해도 100바이트로 저장

유동적이지 않은 길이를 가진 데이터에 효율적

▪️VARCHAR

가변 길이 문자열

VARCHAR(1000) → 10글자 저장하면 10+1(길이 기록용) 바이트로 저장

유동적인 길이 가진 데이터에 효율적

**<큰 데이터 저장>**

▪️TEXT

큰 문자열 저장

주로 게시판의 본문 저장

▪️BLOB

이미지, 동영상 등 큰 데이터 저장

(+ 보통은 아마존의 이미지 서비스인 S3를 이용하는 등 서버에 파일을 올리고 파일 경로를 VARCHAR로 저장함)

**<문자열 열거 타입>**

▪️ENUM

단일 선택만 가능

리스트에 없는 잘못된 값 삽입 - 빈 문자열이 대신 삽입

메모리를 적게 사용하는 이점

▪️SET

여러 개의 데이터 선택 가능

비트 단위의 연산 가능

➡️ 공간적으로 이점 볼 수 있지만, 어플리케이션의 수정에 따라 ENUM, SET 에서 정의한 목록을 수정해야 한다는 단점이 있음

## 1.6 ) 관계

여러 개의 테이블 간의 관계

![image (2)](https://github.com/user-attachments/assets/3524291c-8828-4ede-8287-a76314ae700c)

N:M은 1:N, 1:M 테이블 2개로 나눠서 설정

## 1.7) 키

테이블 간의 관계를 더 명확하게 하고

테이블 자체의 인덱스를 위해 설정된 장치

릴레이션에서 특정 투플을 식별할 때 사용하는 속성, 속성의 집합

### 기본키(Primary Key)

유일성, 최소성 만족하는 키

자연키 또는 인조키 중에 골라서 설정

**🔷 자연키**

중복된 값들을 제외하며 중복되지 않는 것을 자연스럽게 뽑다가 나오는 키

언젠가는 변하는 속성을 가짐

**🔷 인조키**

인위적으로 생성한 키

자연키와는 대조적으로 변하지 않음

보통 기본키는 인조키로 설정

### 외래키(Foreign Key)

다른 테이블의 기본키를 그대로 참조하는 값

개체와의 관계를 식별하는 데에 사용

중복되어도 O

외래키가 성립하기 위해서는 참조하고, 참조되는 양쪽 릴레이션의 도메인이 서로 같아야 함

외래키는 항상 데이터의 일관성을 유지해야 함(**외래키 제약조건**)

Null 값 포함 가능

자기 자신의 기본키를 참조할 수도 있음

### 후보키(Candidate Key)

기본키가 될 수 있는 후보들

유일성과 최소성을 동시에 만족하는 키

투플을 유일하게 식별할 수 있는 속성의 최소 집합

Ex) 슈퍼키인 (주민번호, 이름) 은 후보키가 될 수 없음 - 이름 없어도 돼서 

### 대체키(Alternate Key)

후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들

### 슈퍼키(Super Key)

각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

투플을 유일하게 식별할 수 있는 값이면 모두 가능

슈퍼키는 포함하지 않아도 되는 속성을 포함할 수 있음

Ex) (주민번호, 이름) (고객번호, 이름, 주소)…

