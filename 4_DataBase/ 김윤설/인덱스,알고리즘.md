# 인덱스의 필요성이란?
**데이터를 빠르게 찾을 수 있는 하나의 장치**

- 추가적인 저장 공간을 사용해 테이블 검색 속도 향상
- 인덱스에는 데이터의 키와 데이터의 물리적 위치를 나타냄

단점 
- DB 상 전체 공간의 약 10% 저장공간을 사용함 → 불필요한 저장 공간 낭비가 될 수 있음
- 조회 성능은 증가하나 생성, 삭제, 수정 시 성능 낮아짐

  ## 1) B-Tree (balanced Tree , O(logN))
- 자식 노드가 2개 이상인 트리 ⇒ 노드의 개수를 늘려 tree 전체 높이를 줄여 빠른 탐색 속도를 얻음
- 조회는 빠르나 삽입, 삭제, 수정은 느림 ⇒ 항상 정렬된 상태 유지
- DB 상 B-Tree의 노드:  페이지/블럭 , 노드 내의 데이터: Key
- 일반적인 이진트리와 다르게 한 노드에 여러 데이터를 가질 수 있음 → key 들은 항상 오름차순으로 정렬 상태 유지
- 각 key는 좌우로 다른 노드를 가리키는 포인터를 가지고 있음
- DataPointer : 실제 데이터의 물리적 위치 가리킴
- DB상 특정 컬럼으로 인덱스 생성 가능
  ⇒ 컬럼의 값 : key, 테이블의 행 : dataPointer

## 2) B+Tree (고정적으로 O(logN))
B-Tree 를 개선시킨 자료구조
- 리프노드의 키만 데이터 포인터를 가짐 ⇒ 트리의 높이 낮아짐
- 리프노드를 Linked list로 연결 → 순차 검색에 유리
- 실제로 MySQL(InnoDB) 등 많은 DBMS 사용

## 3) Hash Table
Key 와 Value  쌍으로 데이터 저장하는 자료구조
- O(1) 의 시간복잡도로 접근 가능할 수 있으나 부등호 연산에 부적합
- 정렬되어 있지 않으므로 데이터를 찾기 위해 모든 데이터에 접근


## 인덱스가 효율적인 이유 / 대수확장성

**모든 요소에 접근할 수 있는 균형잡힌 트리 구조**와 **트리 깊이의 대수 확장성** 

⇒ 이로 인해 인덱스가 효율적이다!

# 인덱스 생성 방법

## 인덱스 생성 시 유의사항

- 반드시 PK를 정의하고 최대한 작은 데이터 타입을 선정
- 테이블 PK는 auto_increment를 사용
- 테이블 내 모든 필드에 NOT NULL 속성 추가
    
    → NULL 허용 컬럼을 인덱싱하는 경우 항목마다 한 바이트가 더 소요되기 때문
    
- 파티셔닝을 적절하게 고려하여 데이터를 물리적으로 구분
- 인덱스 개수 최소화
    
    → 인덱스도 서버 자원을 소모하는 자료 구조이기 때문에 성능에 영향이 있음
    
- 인덱스 칼럼은 분포도를 고려하여 선정
    
    → 인덱스 칼럼 데이터의 중복이 줄어들수록 인덱스는 최대의 효과를 가짐
    
    다음 쿼리 값이 1에 가까울수록 인덱스 컬럼으로 적합 (0.9 이상 권고)
    
    ```sql
    SELECT count(distinct INDEX_COLUMN)/count(*)
    FROM TABLE_NAME
    ```
    
- 커버링 인덱스를 활용
    
    <aside>
    커버링 인덱스: 쿼리를 충족시키는데 필요한 모든 데이터를 가지고 있는 인덱스로 SELECT/WHERE/GROUP BY/ORDER BY 등에 활용되는 모든 컬럼이 인덱스의 구성 요소인 경우를 말함
    </aside>
    
- 스토리지 엔진 별 인덱스 특성을 정확하게 인지해야 함
    - InnoDB: 데이터는 PK 순서대로 저장되고 인덱스는 PK를 Vaule로 가짐
    - MyISAM: PK와 일반 인덱스의 구조는 동일하나 Prefix 압축 인덱스 사용 (ORDER BY시 DESC 지양)
- 문자열 인덱싱 시 Prefix 인덱스 활용
    
    <aside>
    💡 Prefix 인덱스: 인덱스의 파티션 키 컬럼과 인덱스를 구성하는 첫 번째 컬럼이 동일한 파티션 인덱스
    
    </aside>
    
- CRC32 함수 및 Trigger를 활용하여 인덱스 생성
    - URL 같이 문자 길이가 긴 경우 유용
    - INSERT/UPDATE 발생 시 Trigger로 CRC32 함수 실행 결과 값을 인덱싱
    - CRC32 결과 값을 저장할 컬럼 추가 및 인덱스 생성
- 중복 인덱스 생성 회피
    
    MySQL에서는 동일한 인덱스를 중복 생성해도 에러가 발생하지 않기 때문에 주의 필요
# 인덱스의 종류
### 클러스터형 인덱스
키 값에 대한 테이블의 데이터 행을 정렬하는 인덱스 유형
테이블 당 하나만 생성 가능하며 실제 데이터 페이지가 인덱스로 지정한 열에 맞춰 자동으로 정렬됨
인덱스를 하나만 생성하는 경우 클러스터형 인덱스를 사용하는 것이 성능상 유리

- PRIMARY KEY에 의해 자동으로 생성
- UNIQUE NOT NULL에 의해 자동으로 생성 (기본키로 만들지 않은 경우)

### 보조 인덱스(세컨더리 인덱스)
여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성
생성 시 별도의 페이지에서 인덱스를 구성하기 때문에 자동으로 정렬하지 않음
여러 개 생성 가능
**차이점**

|  | 클러스터 인덱스 | 보조 인덱스 |
| --- | --- | --- |
| 속도 | 빠르다 | 느리다 |
| 사용 메모리 | 적다 | 많다 |
| 인덱스 | 인덱스가 주요 데이터 | 인덱스가 데이터의 사본(Copy) |
| 개수 | 한 테이블에 한 개 | 한 테이블에 여러 개(최대 약 250개) |
| 리프 노드 | 리프 노드 자체가 데이터 | 리프 노드는 데이터가 저장되는 위치 |
| 저장값 | 데이터를 저장한 블록의 포인터 | 값과 데이터의 위치를 가리키는 포인터 |
| 정렬 | 인덱스 순서와 물리적 순서가 일치 | 인덱스 순서와 물리적 순서가 불일치 |
