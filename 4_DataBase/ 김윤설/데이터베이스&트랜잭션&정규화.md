# 데이터베이스란?

> 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임

# 데이터베이스의 특징

### 독립성(Data Independence)

- **논리적 독립성** : 응용 프로그램과 데이터베이스 간의 독립
    - 데이터의 논리적 구조를 변경시켜도 응용 프로그램의 **논리적 구조는 변경되지 않음**
- **물리적 독립성** : 응용 프로그램과 물리적 장치(ex. 보조기억장치 etc.)간의 독립
    - 데이터베이스 시스템의 성능 향상을 위한 새로운 디스크의 도입에도 응용 프로그램에 영향이 없음
    - 데이터의 **물리적 구조**만을 변경
    - 데이터베이스의 사이즈 변경 시 관련된 응용 프로그램의 수정이 필요 없음
- cf) **종속성**(Data Dependency) : 응용 프로그램의 구조가 데이터의 구조에 영향을 받음

### 무결성 (Data Integrity)

- 데이터의 삽입, 삭제, 갱신 등의 연산 후에도 데이터 베이스에 저장되어있는 데이터가 **정해진 제약조건을 항상 만족**해야 함
- 여러 경로를 통해 잘못된 데이터가 발생하는 경우를 방지하기 위한 목적
- 데이터의 유효성 검사

### 일관성 (Data Consistency)

- 데이터베이스에 저장되어있는 데이터와 특정 질의에 대한 응답이 변함 없이 일정해야 하는 조건
- 관련있는 정보를 논리적인 구조로 관리하는 체계
- 데이터 변경 시 나머지 데이터와 일치하지 않는 **불일치성의 배제**를 위한 목적

### 보안성 (Data Security)

- 데이터로의 접근 권한이 있는 사용자들만 접근할 수 있도록 설정

### 중복성 (Data Redundancy)

- 같은 데이터의 중복 저장
- 데이터의 수정, 삭제가 필요할 경우 연결되어있는 모든 데이터를 수정 및 삭제해줘야 하는 문제점 존재
- **데이터의 통합 관리**를 통해 데이터의 중복을 최소화할 것

# 정규화(Normalization) 역정규화(DeNormalization)

## 정규화

> 관계형 데이터베이스의 설계에서 **중복을 최소화하게 데이터를 구조화하는 프로세스**를 정규화라고 함
정규화의 기본 목표는 **관련이 없는 함수 종속성은 별개의 릴레이션으로** 표현하는 것
> 

장점

- 이상 현상의 발생 가능성 감소

단점

- 연산 시간 증가

### **제 1 정규형**

릴레이션에 속한 모든 속성의 도메인이 **더 이상 분해되지 않는 원자값으로만 구성**된 정규형

### **제2정규형**

릴레이션이 제1정규형에 속하고, **기본키가 아닌 모든 속성이 기본키에 완전 함수 종속**

### **제3정규형**

릴레이션이 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 **이행적 함수 종속이 되지 않음**

### **BCNF**

릴레이션의 함수 종속 관계에서 **모든 결정자가 후보키**

### 제4정규형

릴레이션이 BCNF를 만족하면서, 함수 종속이 아닌 **다치 종속**(MVD: Multi Valued Dependency) 를 제거해야 만족

### 제5정규형

릴레이션이 제4정규형을 만족하면서 후보키를 통하지 않는 **조인 종속**(JD: Join Dependency) 을 제거해야 만족

⇒ 데이터베이스를 설계할 때 모든 릴레이션이 무조건 제5정규형에 속하도록 분해해야 하는 것 X

오히려 그렇게 되면 비효율적일 수 있음

⇒ 일반적으로 **제3정규형**이나 **BCNF**에 속하도록 릴레이션을 분해하여 **데이터 중복을 줄이고 이상 현상이 발생하는 문제를 해결**한다고 한다.

## 역정규화

> 역정규화는  중복을 허용하며 Entity를 다시 통합하거나 분할하여 정규화 과정을 통해 도출된 DB 구조를 재조정하는 과정
> 

Join이 너무 많아지는 DB 설계와 쿼리는 요청을 처리하는 시간을 증가시키는 문제 발생

→모든 주요 Entity를 분리하는 것이 좋은 것이 아니라 DB의 전반적인 성능을 향상시킬 수 있는 구조화 과정을 거치는 것이 필요

## 이상현상

> 테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 논리적으로 생기는 오류
> 

### 1. 삽입 이상

자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상

### 2. 갱신 이상

중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상

### 3. 삭제 이상

어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상

⇒ 이상 현상을 예방하고 효과적인 연산을 하기 위해데이터 정규화(Data Normalication) 필요
# 트랜잭션

> DB의 상태를 변경시키는 작업의 단위
→  한꺼번에 수행되어야 할 연산을 모아놓은 것
> 

연산들을 모두 처리하지 못 한 경우에는 원 상태로 복구한다. 즉, 작업의 일부만 적용되는 현상이 발생하지 않는다.

이를 통해 트랜잭션은 작업의 **완전성**을 보장

사용자의 입장에서는 ***작업의 논리적 단위*** 이고,

시스템의 입장에서는 ***데이터들을 접근 또는 변경하는 프로그램의 단위***

## 트랙잭션의 4가지 특성 ACID

### Atomicity (원자성)

트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다 (All or Nothing).

### Consistenty (일관성)

트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.

시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 수행 후의 상태가 같아야 한다는 말로,

DB의 제약조건을 위배하는 작업을 트랜잭션 과정에서 수행할 수 없음을 나타낸다.

*ex) 송금 시 금액의 데이터 타입을 정수형(integer)에서 문자열(string)로 변경할 수 없음.*

### Isolation (독립성)

둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.

### Durability (지속성)

트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

## 트랙잭션의 연산

### COMMIT

**트랜잭션이 성공적으로 수행되었음을 선언하는 연산**

→ 그 결과를 최종 DB에 반영

### ROLLBACK

**트랜잭션 수행이 실패했음을 선언하고 작업을 취소하는 연산**

→ DB를 트랜잭션 수행 전과 일관된 상태로 되돌림

## 트랙잭션 사용 시 주의할 점

꼭 필요한 최소한의 코드에만 적용하는 것이 좋다. 즉, 트랜잭션의 범위를 최소화하라는 말이다.

일반적으로 DB 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어지면, 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있기 때문이다.

## 트랙잭션 격리 수준(**Isolation Level**)

> **동시에 여러 트랜잭션이 처리될 때 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것
→ 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것**
> 

1. **READ UNCOMMITTED**
2. **READ COMMITED**
3. **REPEATABLE READ**
4. **SERIALIZABLE**

(oracle의 디폴트 = **READ COMMITED**, MySQL의 디폴트 = **REPEATABLE READ**)

**SERIALIZABLE가 트랙잭션 간 고립 정도 가장 높음 & 성능 낮음**

### **READ UNCOMMITTED (레벨 0) - 커밋되지 않는 읽기**

- 각 트랜잭션에서의 변경 내용을 `COMMIT` 이나 `ROLLBACK` 여부에 상관없이 다른 트랜잭션에서 값을 읽을 수 있다.
- 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장.
- **DIRTY READ** 현상 발생
    - DIRTY READ: 트랜잭션 작업이 완료되지 않았음에도 다른 트랜잭션에서 볼 수 있게 됨

### **READ COMMITED (레벨 1) - 커밋된 읽기**

- RDB에서 대부분 기본적으로 사용되고 있는 격리 수준
- 실제 테이블 값을 각져오는 것이 아니라, **Undo 영역에 백업된 레코드**에서 값을 가져옴
- DIRTY READ와 같은 현상 발생 X
- **Non-repeatable Read** 현상 발생
    - Non-repeatable Read: 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션 값을 수정 or 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

### **REPEATABLE READ (레벨 2) - 반복가능한 읽기**

- Undo 공간에 백업해두고 실제 레코드 값을 변경
- MySQL에서는 트랜잭션마다 **트랜잭션 ID**를 부여해 트랜잭션 ID보다 작은 번호에서 변경한 것만 읽음
- 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제
- Undo에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있음
- 이러한 변경방식을 *MVCC(Multi Version Concurrency Control)* 라고 부름
- **PHANTOM READ** 현상 발생
    - PHANTOM READ: 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
    - **REPEATABLE READ** 에 의하면 원래 출력되지 않아야 하는데 Update 영향을 받은 후부터 출력
    - 방지 방법: 쓰기(write) 잠금을 걸어야 함

### **SERIALIZABLE (레벨 3) - 직렬화 가능**

- 가장 단순한 격리 수준이면서 가장 엄격한 격리 수준
- **완벽한 읽기 일관성 모드** 제공
- 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능
- 성능 측면에서는, 동시 처리 성능 가장 낮음
- PHANTOM READ 발생 X
- DB에서 거의 사용 X
